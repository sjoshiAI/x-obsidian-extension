console.log('X to Obsidian background script loaded');

class BackgroundService {
  constructor() {
    this.urls = new Map();
    this.init();
  }

  async init() {
    await this.loadStoredUrls();
    this.setupMessageListener();
    this.updateBadge();
  }

  setupMessageListener() {
    chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
      console.log('Received message:', request.action);
      
      switch (request.action) {
        case 'saveUrl':
          this.saveUrl(request.data);
          sendResponse({ success: true });
          break;
          
        case 'getUrls':
          sendResponse({ 
            success: true, 
            urls: Array.from(this.urls.values()) 
          });
          break;
          
        case 'exportUrls':
          this.exportUrls()
            .then(result => sendResponse(result))
            .catch(error => sendResponse({ success: false, error: error.message }));
          return true; // Keep message channel open for async response
          
        case 'clearUrls':
          this.clearUrls();
          sendResponse({ success: true });
          break;
          
        default:
          sendResponse({ success: false, error: 'Unknown action' });
      }
    });
  }

  async loadStoredUrls() {
    try {
      const result = await chrome.storage.local.get('urls');
      if (result.urls) {
        this.urls = new Map(Object.entries(result.urls));
      }
      console.log(`Loaded ${this.urls.size} stored URLs`);
    } catch (error) {
      console.error('Error loading URLs:', error);
    }
  }

  async saveStoredUrls() {
    try {
      const urlsObj = Object.fromEntries(this.urls);
      await chrome.storage.local.set({ urls: urlsObj });
      console.log(`Saved ${this.urls.size} URLs`);
    } catch (error) {
      console.error('Error saving URLs:', error);
    }
  }

  saveUrl(urlData) {
    if (!this.urls.has(urlData.url)) {
      this.urls.set(urlData.url, {
        ...urlData,
        id: Date.now().toString(),
        dateAdded: new Date().toISOString()
      });
      
      this.saveStoredUrls();
      this.updateBadge();
      console.log('Saved URL:', urlData.url);
    }
  }

  async exportUrls() {
    if (this.urls.size === 0) {
      return { success: false, error: 'No URLs to export' };
    }

    try {
      const markdown = this.generateMarkdown();
      const filename = `x-reading-list-${new Date().toISOString().split('T')[0]}.md`;
      
      // Create blob and download
      const blob = new Blob([markdown], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      
      await chrome.downloads.download({
        url: url,
        filename: filename,
        saveAs: true
      });
      
      // Clean up
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      
      return {
        success: true,
        filename: filename,
        count: this.urls.size
      };
      
    } catch (error) {
      console.error('Export error:', error);
      return { success: false, error: error.message };
    }
  }

  generateMarkdown() {
    const urls = Array.from(this.urls.values());
    const date = new Date().toLocaleDateString();
    
    let markdown = `# ðŸ“š X Reading List - ${date}\n\n`;
    markdown += `> Extracted from X (Twitter)\n`;
    markdown += `> Total URLs: ${urls.length}\n\n`;
    markdown += `---\n\n`;
    
    // Group by domain
    const byDomain = this.groupByDomain(urls);
    
    Object.entries(byDomain).forEach(([domain, domainUrls]) => {
      markdown += `## ðŸŒ ${domain}\n\n`;
      markdown += `*${domainUrls.length} URLs*\n\n`;
      
      domainUrls.forEach((item, index) => {
        markdown += `### ${index + 1}. ${item.title}\n\n`;
        markdown += `**ðŸ”— URL:** ${item.url}\n\n`;
        
        if (item.tweetText && item.tweetText.length > 0) {
          markdown += `**ðŸ’¬ Context:** "${item.tweetText}"\n\n`;
        }
        
        markdown += `**ðŸ‘¤ Author:** ${item.author}\n`;
        markdown += `**ðŸ“… Added:** ${new Date(item.dateAdded).toLocaleString()}\n\n`;
        markdown += `---\n\n`;
      });
    });
    
    markdown += `\n*Generated by X to Obsidian Extension*`;
    return markdown;
  }

  groupByDomain(urls) {
    const groups = {};
    
    urls.forEach(item => {
      try {
        const domain = new URL(item.url).hostname;
        if (!groups[domain]) {
          groups[domain] = [];
        }
        groups[domain].push(item);
      } catch {
        if (!groups['unknown']) {
          groups['unknown'] = [];
        }
        groups['unknown'].push(item);
      }
    });
    
    return groups;
  }

  clearUrls() {
    this.urls.clear();
    this.saveStoredUrls();
    this.updateBadge();
    console.log('Cleared all URLs');
  }

  updateBadge() {
    const count = this.urls.size;
    chrome.action.setBadgeText({ 
      text: count > 0 ? count.toString() : '' 
    });
    chrome.action.setBadgeBackgroundColor({ color: '#1DA1F2' });
  }
}

// Initialize background service
new BackgroundService();